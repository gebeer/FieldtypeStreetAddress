<?php namespace ProcessWire;


/**
 * ProcessWire Address Fieldtype
 * Copyright 2018 Netcarver.
 *
 * Field that stores string values for street addresses.
 *
 * ProcessWire 3
 * Copyright (C) 2017 by Ryan Cramer
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class FieldtypeStreetAddress extends Fieldtype
{

    /**
     *
     */
    public static function getModuleInfo()
    {
        return [
            'title'    => __('Street Address'),
            'summary'  => __("Fieldtype to store a street address and allows access to it's subfields."),
            'version'  => '1.0.3',
            'author'   => 'Netcarver',
            'installs' => 'InputfieldStreetAddress, InputfieldAsmSelect',
            'icon'     => 'envelope',
            'require'  => 'php>5.4.0',
        ];
    }



    /**
     *
     */
    public function init() {
        parent::init();
        $dir = dirname(__FILE__);
        require_once "$dir/StreetAddress.php";
    }



    /**
     * Allow checking for empty values in conditionals
     */
    public function isEmptyValue(Field $field, $value) {
        return $value->isEmpty();
    }



    /**
     *
     */
    public static function prepareLinesCallback($line, $key, $data = [])
    {
        $parser = @$data['parser'];
        if ($parser) {
            $line = str_replace('.parent', '', $line); // prevent traversal up the page tree
            $parser->format($line);
        }

        return $line;
    }



    /**
     * Add a before hook to this method to allow adjustment of the address lines stored in the street address.
     */
    public function ___formatValue(Page $page, Field $field, $street_address)
    {
        return self::format($page, $field, $street_address);
    }



    /**
     * Format street address for output
     */
    public static function format(Page $page, Field $field, $street_address)
    {
        $parser = false;
        $html   = 0 == $field->outputHTML;

        /**
         * Set up the tag parser to process the line...
         */
        if (wire('modules')->isInstalled('TextformatterTagParser')) {
            $parser = wire('modules')->get("TextformatterTagParser");
            $parser->set('context', ['page' => $page]);
        }

        /**
         * Use the owning field's settings to determine display of the address field...
         */
        switch ($field->showOutputCountry) {
        case 0:
            $street_address->origin_iso = $street_address->country_iso;
            break;

        case 1:
            $street_address->origin_iso = '++';
            break;

        case 2:
            $street_address->origin_iso = $field->originISO;
            break;
        }

        $street_address->prepareLines(
            [__CLASS__, 'prepareLinesCallback'],
            [
                'parser' => $parser,
                'html'   => $html,
            ]
        );

        /**
         * Get the address to format itself...
         */
        if ($field->outputSingleLine == 1) {
            $address = $street_address->formatSingle($html);
        } else {
            $address = $street_address->format($html);
        }

        return $address;
    }



    /**
     * Add mapping to different name for use in page selectors
     * This enables us to use it like "address.city=Exeter, address.country_iso=GB"
     */
    public function getMatchQuery($query, $table, $subfield, $operator, $value)
    {
        $subfields = StreetAddress::getAddressFieldNames();
        if ($subfield == 'country_iso') {
            $subfield = 'data';
        } else if (in_array($subfield, $subfields)) {
            $subfield = 'data_' . $subfield;
        }
        return parent::getMatchQuery($query, $table, $subfield, $operator, $value);
    }



    /**
     *
     */
    public function getInputfield(Page $page, Field $field)
    {
        $inputfield = $this->modules->get('InputfieldStreetAddress');

        // This inputfield uses a page & field object.
        $inputfield->setPage($page);
        $inputfield->setField($field);

        return $inputfield;
    }



    /**
     * There are no compatible fieldtypes that I know of.
     */
    public function ___getCompatibleFieldtypes(Field $field)
    {
        return null;
    }



    /**
     *
     */
    public function getBlankValue(Page $page, Field $field)
    {
        return new StreetAddress();
    }



    /**
     * Any value will get sanitized before setting it to a page object
     * and before saving the data
     */
    public function sanitizeValue(Page $page, Field $field, $value)
    {
        if(!$value instanceof StreetAddress) {
            $value = $this->getBlankValue($page, $field);
        }

        // All known postal codes use capital letters if they use letters at all, so...
        $value->postal_code = mb_convert_case($value->postal_code, MB_CASE_UPPER, 'UTF-8');

        $changes   = 0;
        $subfields = StreetAddress::getAddressFieldNames();
        foreach ($subfields as $f) {
            $value->$f = trim($value->$f); // We don't store runs of spaces at start or end of a string.
            if ($value->isChanged($f)) {
                $changes++;
            }
        }
        if ($changes > 0) {
            $page->trackChange($field->name);
        }

        return $value;
    }



    /**
     *
     */
    public function ___wakeupValue(Page $page, Field $field, $value)
    {
        $address   = $this->getBlankValue($page, $field);
        $subfields = StreetAddress::getAddressFieldNames();
        $san       = $this->wire('sanitizer');

        // populate the address
        $address->country_iso = $san->text($value['data']);
        foreach ($subfields as $f) {
            if ('country_iso' === $f) continue;
            if ('origin_iso' === $f) continue;
            $address->$f = $san->text(trim($value["data_$f"]));
        }
        $address->snapshot(); // Allow the isChanged() function to work.

        return $address;
    }




    /**
     *
     */
    public function ___sleepValue(Page $page, Field $field, $value)
    {
        if(!$value instanceof StreetAddress) {
            throw new WireException("Expecting an instance of StreetAddress");
        }

        $san        = $this->wire('sanitizer');
        $sleepValue = [];
        $changed    = [];
        $subfields  = StreetAddress::getAddressFieldNames();
        foreach ($subfields as $f) {
            if (in_array($f, ['origin_iso', 'country'])) continue;
            $pre  = $value->$f;
            $post = $san->text(trim($pre));
            if ('country_iso' === $f) {
                $sleepValue["data"] = $post;
            } else {
                $sleepValue["data_$f"] = $post;
            }
        }

        /* if (!empty($changed)) { */
        /*     // Cache formatted HTML and standard values? */
        /* } */

        return $sleepValue;
    }



    /**
     * Get the database schema for this field
     *
     * @param Field $field In case it's needed for the schema, but usually should not.
     * @return array
     */
    public function getDatabaseSchema(Field $field)
    {
        $schema = parent::getDatabaseSchema($field);
        $subfields = StreetAddress::getAddressFieldNames();
        foreach ($subfields as $f) {
            if ('country_iso' === $f) {
                $schema['data']     = 'VARCHAR(3) NOT NULL default ""';
            } else {
                $schema['data_'.$f] = 'VARCHAR(128) NOT NULL default ""';
                $schema['keys']['data_'.$f] = "KEY data_$f(`data_$f`)";
            }
        }

        return $schema;
    }



    protected function ___getCountryList()
    {
        $dir = dirname(__FILE__);
        $countries = include "$dir/countries.php";
        array_walk($countries, function(&$country) {
            $country = str_replace('_', ' ', strip_tags($country));
            $country = mb_convert_case($country, MB_CASE_TITLE, 'UTF-8');
        });
        return $countries;
    }



    /**
     *
     */
    public function ___getConfigAllowContext(Field $field) {
        return [
            'permittedISOs',
            'defaultISO',
            'showInputCountry',
            'inputFormat',
            'showAddressPreview',
            'showAddressPreviewHTML',
            'hideEmptyFields',
            'outputHTML',
            'outputSingleLine',
            'showOutputCountry',
            /* 'originISO', */
        ];
    }



    /**
     * Get any inputfields used for configuration of this Fieldtype.
     *
     * This is in addition any configuration fields supplied by the parent Inputfield.
     *
     * @param Field $field
     * @return InputfieldWrapper
     *
     */
    public function ___getConfigInputfields(Field $field)
    {
        $inputfields = parent::___getConfigInputfields($field);

        $input_wrapper = $this->modules->get('InputfieldFieldset');
        $input_wrapper->label = __("Input Options");
        $inputfields->append($input_wrapper);

        /**
         * Set the allowable countries for this address field.
         *
         * This determines the field layout for the inputfield and also the format of the output address (as it varies
         * from country to country.)
         *
         * not set => user has unrestricted choice of countries and the defaultISO defines the default country
         *  1  set => user has no input choice, the addresses have a fixed country (and therefore format)
         *  n  set => user has a restricted choice of n countries in the input field.
         */
        $f = $this->modules->get('InputfieldAsmSelect');
        $f->label = $this->_('Allowable Countries');
        $f->attr('id+name', 'permittedISOs');
        $f->description = $this->_('Destination countries control the layout of the inputfields and the formatted output.');
        $f->notes = $this->_('For a single country, please choose one country from the list.') . ' ' .
            $this->_('To allow a limited choice of formats, choose all applicable countries or simply leave this empty to allow free choice from all formats.');
        $f->attr('value', $field->permittedISOs);
        foreach($this->getCountryList() as $iso => $country) {
            $code    = strtoupper($iso);
            $f->addOption($iso, "$country ($code)");
        }
        $input_wrapper->append($f);

        /**
         * Set the default address format - country ISO.
         */
        $f = $this->modules->get('InputfieldSelect');
        $f->label = $this->_('Default Country');
        $f->attr('id+name', 'defaultISO');
        $f->description = $this->_('Which country will be selected by default - this country will be added to the "Allowable Countries" if needed.');
        $f->attr('value', $field->defaultISO);
        foreach($this->getCountryList() as $iso => $country) {
            $code    = strtoupper($iso);
            $f->addOption($iso, "$country ($code)");
        }
        $f->showIf = "permittedISOs.count!=1";
        $input_wrapper->append($f);

        /**
         * Force display of the country field in the output, even if it is fixed?
         */
        $f = $this->wire('modules')->get('InputfieldRadios');
        $f->label = $this->_('Show Country Input?');
        $f->attr('id+name', 'showInputCountry');
        $f->description = $this->_('Should the country field be shown, even though these addresses all use the same country?');
        $f->addOption(0, $this->_('No, do not show the country field.'));
        $f->addOption(1, $this->_('Yes, show the country field.'));
        $f->attr('value', (int) $field->showInputCountry);
        $f->showIf = "permittedISOs.count=1";
        $input_wrapper->add($f);

        /**
         * How should the input fields be shown?
         */
        $f = $this->wire('modules')->get('InputfieldRadios');
        $f->label = $this->_('Select Input Format');
        //$f->attr('id+name', 'inputFormat');
        $f->attr('name', 'inputFormat');
        $f->description = $this->_('How should the inputfields be configured?');
        $f->addOption(0, $this->_("Use destination country's field layout."));
        $f->addOption(1, $this->_('Fixed data table showing all fields.'));
        $f->attr('value', (int) $field->inputFormat);
        $f->columnWidth = 33;
        $input_wrapper->add($f);

        /**
         * Show address preview panel?
         */
        $f = $this->wire('modules')->get('InputfieldRadios');
        $f->label = $this->_('Show Address Preview?');
        $f->attr('name', 'showAddressPreview');
        $f->description = $this->_('Choose "Yes" to see what the address looks like once submitted.');
        $f->addOption(0, $this->_('No.'));
        $f->addOption(1, $this->_('Yes.'));
        $f->attr('value', (int) $field->showAddressPreview);
        $f->columnWidth = 34;
        $f->showIf = "inputFormat=0";
        $input_wrapper->add($f);

        /**
         * Include preview of HTML output?
         */
        $f = $this->wire('modules')->get('InputfieldRadios');
        $f->label = $this->_('Show Underlying HTML in Preview?');
        $f->attr('id+name', 'showAddressPreviewHTML');
        $f->description = $this->_('Choose "Yes" to see underlying HTML (if any)');
        $f->addOption(0, $this->_('No.'));
        $f->addOption(1, $this->_('Yes.'));
        $f->attr('value', (int) $field->showAddressPreviewHTML);
        $f->columnWidth = 33;
        $f->showIf = "inputFormat=0, showAddressPreview=1";
        $input_wrapper->add($f);

        /**
         * Surpress fields...
         */
        $f = $this->modules->get('InputfieldAsmSelect');
        $f->label = $this->_('Hide Empty Fields...');
        $f->attr('id+name', 'hideEmptyFields');
        $f->description = $this->_('Which fields should be hidden from the input by default? Choose all that apply.');
        $f->attr('value', $field->hideEmptyFields);
        $f->addOption('admin_area');
        $f->addOption('locality');
        $f->addOption('recipient');
        $f->addOption('organization');
        $f->addOption('dependent_locality');
        $f->addOption('postal_code');
        $f->addOption('sorting_code');
        $f->showIf = "inputFormat=0";
        $input_wrapper->append($f);



        $output_wrapper = $this->modules->get('InputfieldFieldset');
        $output_wrapper->label = __("Output Formatting Options");

        /**
         * HTML or plaintext output?
         */
        $f = $this->wire('modules')->get('InputfieldRadios');
        $f->label = $this->_('Include HTML Microformat Spans In Output?');
        $f->attr('id+name', 'outputHTML');
        $f->addOption(0, $this->_('Yes, include spans.'));
        $f->addOption(1, $this->_('No, just plaintext.'));
        $f->attr('value', (int) $field->outputHTML);
        $f->columnWidth = 50;
        $output_wrapper->add($f);


        /**
         * Single or Multiline output?
         */
        $f = $this->wire('modules')->get('InputfieldRadios');
        $f->label = $this->_('Format as Single/Multiline Output?');
        $f->attr('id+name', 'outputSingleLine');
        $f->addOption(0, $this->_('Use as many lines as needed.'));
        $f->addOption(1, $this->_('Just a single line.'));
        $f->attr('value', (int) $field->outputSingleLine);
        $f->columnWidth = 50;
        $output_wrapper->add($f);


        /**
         * Force display of the country field in the output, even if it is fixed?
         */
        $f = $this->wire('modules')->get('InputfieldRadios');
        $f->label = $this->_('Show the destination country field?');
        $f->description = $this->_('Sometimes it is not necessary to show the destination country, such as when mail is being sent domestically.');
        $f->attr('name', 'showOutputCountry');
        $f->addOption(0, $this->_('Never - All addresses are domestic.'));
        $f->addOption(1, $this->_('Always - All addresses are international.'));
        $f->addOption(2, $this->_('Conditionally - Only show if the Country of Origin is different from the country in the address.'));
        $f->attr('value', (int) $field->showOutputCountry);
        $f->columnWidth = 100;
        $output_wrapper->add($f);


        /**
         * Set the Country-of-Origin ISO.
         */
        $f = $this->modules->get('InputfieldSelect');
        $f->label = $this->_('Country of Origin');
        $f->attr('name', 'originISO');
        $f->description = $this->_('please specify the country of origin for any post you might send.');
        foreach($this->getCountryList() as $iso => $country) {
            $code    = strtoupper($iso);
            $f->addOption($iso, "$country ($code)");
        }
        $f->attr('value', $field->originISO);
        $f->columnWidth = 50;
        $f->showIf = 'showOutputCountry=2';
        $output_wrapper->append($f);


        $inputfields->append($output_wrapper);

        return $inputfields;
    }


    public function upgrade($fromVersion, $toVersion) {
        if ($fromVersion !== $toVersion) {
            // Try copying the format overrides file back into our location from where the PW Upgrades module may have
            // moved it. This allows preservation of an installation's formats_overrides.php file between upgrades done
            // with the PW Upgrades module. Manual upgrades by unpacking a zip in place should not overwrite the
            // destination file as it doesn't exist in the source zip.

            $sitemods = wire('config')->paths->siteModules;
            $backup   = "$sitemods/.FieldtypeStreetAddress";
            $file     = "formats_overrides.php";
            $src      = "$backup/$file";
            $dest     = __DIR__."/$file";

            if (file_exists($src) && !file_exists($dest)) {
                copy($src, $dest);
            }
        }
    }
}
