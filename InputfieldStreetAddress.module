<?php namespace ProcessWire;


/**
 *
 */
class InputfieldStreetAddress extends Inputfield
{

    /**
     *
     */
    public static function getModuleInfo()
    {
        return [
            'title'    => __('Street Address'),
            'summary'  => __('Allows country-specific layout and formatting of street addresses.'),
            'version'  => '0.0.3',
            'icon'     => 'envelope',
            'author'   => 'Netcarver',
            'requires' => ["FieldtypeStreetAddress", "MarkupAdminDataTable", "JquerySelectize", "TextformatterTagParser"],
        ];
    }



    /**
     *
     */
    public function __construct()
    {
        $this->set('permittedISOs', '');            // Allowable country codes
        $this->set('defaultISO', 'us');             // The default country code for new address fields when there is more than one allowable
        $this->set('showInputCountry', 0);          // Show country input if there is only one allowable country?
        $this->set('showOutputCountry', 0);         // Show country in output (never/always/if international)
        $this->set('inputFormat', 0);               // Controls how the inputfield looks
        $this->set('surpressUnneededFields', 0);    // Show optional fields by default.
        $this->set('validatePostalCode', 0);        // Off by default.
        $this->set('originISO', 'us');              // Helps control address formatting output.
        $this->set('showAddressPreview', 0);        // Show a preview pane with the formatted address.
        parent::__construct();
    }



    /**
     * Page object that houses this field. Used to allow context-sensitive-tag-parser to pull in other fields from the
     * page into the address.
     */
    protected $page;
    public function setPage(Page $page)
    {
        $this->page = $page;
    }


    /**
     *
     */
    public function init()
    {
        $this->modules->JquerySelectize;
        $dir = dirname(__FILE__);
        require_once "$dir/StreetAddress.php";
        return parent::init();
    }



    /**
     *
     */
    protected static function makeTitle(array $parts)
    {
        array_walk($parts, function(&$item, $key) {
            $item = mb_convert_case(str_replace('_', ' ', strip_tags($item)), MB_CASE_TITLE, 'UTF-8');
        });
        return implode(__(', '), $parts);
    }



    /**
     *
     */
    protected static function getCountryList()
    {
        $list = include __DIR__."/countries.php";
        if (!is_array($list)) {
            $list = ['gb' => 'United Kingdom'];
        } else {
            array_walk($list, function(&$item) {
                //$item = htmlspecialchars(mb_convert_case(strip_tags($item), MB_CASE_TITLE, 'UTF-8'), ENT_HTML5 | ENT_QUOTES, 'utf-8');
                $item = htmlentities(strip_tags($item), ENT_HTML5 | ENT_QUOTES, 'utf-8');
            });
        }
        return $list;
    }



    /**
     * @var $data     array     Array Keys are used as select option values, array Values are used as option labels.
     * @var $id       string    The HTML id of the control
     * @var $name     string    The HTML name of the control
     * @var $current  string    The current value of the data. Defaults to an empty string
     * @var $attr     string    String of extra HTML attributes to add to the control
     */
    protected static function makeDatalist($data, $id, $name, $current='', $attr='')
    {
        $id  = htmlspecialchars(strip_tags($id), ENT_HTML5 | ENT_QUOTES, 'utf-8');
        $out = "<select $attr id='$id' name='$name' placeholder='Country (required)' class='streetaddress streetaddress_country'>";
        foreach ($data as $iso => $country) {
            //$country = htmlspecialchars(mb_convert_case(strip_tags($country), MB_CASE_TITLE, 'UTF-8'), ENT_HTML5 | ENT_QUOTES, 'utf-8');
            $selected = ($current === $iso) ? 'selected=selected ' : '';
            $code     = strtoupper($iso);
            $out .= "<option {$selected}value=\"$iso\" data-name=\"$country\">$country ($code)</option>";
        }
        $out.= "</select>";
        return $out;
    }



    /**
     *
     */
    protected function makeCountryInput($allowed_country_codes, $default_country_iso, StreetAddress &$value)
    {
        $all_countries       = self::getCountryList();
        $current_country_iso = strtolower($value->country_iso);

        // An empty allowed countries list => free choice of any country, so populate the array.
        if (empty($allowed_country_codes)) {
            $allowed_country_codes = array_keys($all_countries);
        }

        $num_allowed = count($allowed_country_codes);

        // Make sure the default country is in the list as long as there is more than one choice. Otherwise the single
        // choice will override the default_country_iso.
        if ($num_allowed > 1 && !in_array($default_country_iso, $allowed_country_codes)) {
            $allowed_country_codes[] = $default_country_iso;
        }

        if ('' === $current_country_iso) {
            // Handle new, blank iso values. For a single entry list, the value overrides any default country as that is
            // only used when there is a multiple choice.
            $value->country_iso = (1 === $num_allowed) ? $allowed_country_codes[0] : $default_country_iso;
            $current_country_iso = $value->country_iso;
        } else if (!in_array($current_country_iso, $allowed_country_codes)) {
            // Ensure the non-blank current country is in the list...
            $allowed_country_codes[] = $current_country_iso;
        }

        // Build array of allowed countries and their names...
        $allowed_country_codes = array_flip($allowed_country_codes);
        $allowed_country_codes = array_intersect_key($all_countries, $allowed_country_codes);
        $attr                  = '';
        $name                  = "{$this->name}_country_iso";
        $id                    = "Inputfield_$name";

        $num_allowed = count($allowed_country_codes);
        if (1 === $num_allowed) {
            $attr = 'disabled=disabled';
        }

        $out = self::makeDatalist($allowed_country_codes, $id, $name, $current_country_iso, $attr);

        if (1 === $num_allowed && 0 == $this->showInputCountry) {
            $out = "<div hidden>$out</div>";
        }
        return $out;
    }



    /**
     * Return the completed output of this Inputfield, ready for insertion in an XHTML form
     *
     * @return string
     */
    public function ___render()
    {
        $value             = $this->attr('value') ? $this->attr('value') : new StreetAddress();
        $country_input     = $this->makeCountryInput($this->permittedISOs, $this->defaultISO, $value);
        $iso               = $value->country_iso;
        $country_of_origin = $this->originISO;
        $show_country      = $this->inputShowCountryField;
        $fields            = StreetAddress::getAddressFieldNames();
        $mappings          = StreetAddress::getAddressMappings();
        $known             = false;

        if (0 == $this->inputFormat && '' !== $iso) {
            $fmt = StreetAddress::getFormat($iso);
            $addressfields = @$fmt['fmt'];

            if ('' !== trim($addressfields)) {
                /**
                 * Address format is known, so build the input form from the format.
                 */
                $known  = true;
                $out    = [];
                $unused = $mappings;

                $required_fields = @$fmt['require'];
                if (empty($required_fields)) {
                    $required_fields = 'ACZ';
                }
                $required_fields = str_split($required_fields);

                if (false === strpos($addressfields, '%R')) {
                    $addressfields .= "%n%R";
                }
                //$addressfields = str_replace('%N', '', $addressfields); // TODO Make these configurable?
                //$addressfields = str_replace('%O', '', $addressfields);
                $addressfields = explode('%', $addressfields);
                array_shift($addressfields);

                foreach ($addressfields as $f) {
                    $fmtcode     = substr($f, 0, 1);
                    $suffix      = substr($f, 1);

                    /**
                     * Remove this field from the unused pool that will be output as hidden controls later...
                     */
                    unset($unused[$fmtcode]);

                    $is_required = in_array($fmtcode, $required_fields);
                    $key         = @$mappings[$fmtcode];
                    $classes     = ['streetaddress'];
                    $parts       = [$key];
                    $parts[]     = ($is_required) ?
                                    __('Required') :
                                    __('Optional');
                    $is_missing  = ($is_required && empty($value->$key));
                    if ($is_missing) {
                        $parts[] = __('Missing');
                        $classes[] = 'streetaddress_missing streetaddress_malformed';
                    }
                    $title       = self::makeTitle($parts);
                    $ph          = self::makeTitle([$key]);

                    if (!$is_required && 'country' !== $key) {
                        $classes[] = 'streetaddress_optional';
                        if (!empty($key) && strlen((string)$value->$key) > 0) {
                            $classes[] = 'streetaddress_optional_nonempty';
                        }
                    }
                    if ($is_required) {
                        $classes[] = 'required';
                    }
                    $classes = implode(' ', $classes);


                    if ('R' === $fmtcode) {
                        $out[] = $country_input;
                    } else if ('A' === $fmtcode) {
                        $key2 = 'street_address_2';
                        $fieldvalue   = htmlspecialchars($value->$key, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                        $out[] = "<input title='$title' class='$classes' placeholder='$ph' type='text' name='{$this->name}_$key' maxlength=128 id='Inputfield_{$this->name}_$key' value='{$fieldvalue}'/><br>";
                        $fieldvalue2  = htmlspecialchars($value->$key2, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                        $classes .= ' streetaddress_optional';
                        if ('' !== $fieldvalue2) {
                            $classes .= ' streetaddress_optional_nonempty';
                        }
                        $title = __('Street Address Line 2, Optional');
                        $ph    = __('Street Address Line 2');
                        $out[] = "<input title='$title' class='$classes' placeholder='$ph' type='text' name='{$this->name}_$key2' maxlength=128 id='Inputfield_{$this->name}_$key2' value='{$fieldvalue2}'/>";
                    } else if ('Z' === $fmtcode) {
                        $fieldvalue   = htmlspecialchars($value->$key, ENT_HTML5 | ENT_QUOTES, 'UTF-8');

                        // Regex verify the postal code field...
                        $regex = @$fmt['zip'];

                        if ($regex) {
                            $m = [];
                            $regex = "~$regex~";
                            $result = preg_match($regex, $fieldvalue, $m);
                            $malformed = (0 === $result) || ($m[0] !== $fieldvalue);
                            if ($malformed) {
                                $classes .= " streetaddress_malformed";
                                $title   .= ', ' . __("Malformed");
                            }
                        }

                        $out[] = "<input title='$title' class='$classes' placeholder='$ph' type='text' name='{$this->name}_$key' maxlength=128 id='Inputfield_{$this->name}_$key' value='{$fieldvalue}'/>";

                    } else if (array_key_exists($fmtcode, $mappings)) {
                        $fieldvalue   = htmlspecialchars($value->$key, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                        $out[] = "<input title='$title' class='$classes' placeholder='$ph' type='text' name='{$this->name}_$key' maxlength=128 id='Inputfield_{$this->name}_$key' value='{$fieldvalue}'/>";
                    } else if ('n' === $fmtcode) {
                        // Pass over leading 'n' markers. These can be left over from removing the recipient and/or organisation.
                        if (!empty($out)) {
                            $out[] = "\n";
                        }
                    }

                    if (!empty($suffix)) {
                        $out[] = "<span class='streetaddress_suffix'>$suffix</span>";
                    }
                }

                /**
                 * Compose into output, removing unneeded repeat newlines...
                 */
                $out = implode('', $out);
                $out = preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $out);
                $out = nl2br($out);

                /**
                 * Render the unused fields so they get saved too. This is done to avoid loss of data from fields should
                 * the country be switched.
                 */
                $unused_out = '';
                foreach ($unused as $key) {
                    $ph          = self::makeTitle([$key]);
                    $name  = $this->name . "_$key";
                    $id    = 'Inputfield_' . $name;
                    $fieldvalue  = htmlspecialchars($value->$key, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                    $unused_out .= "<input hidden readonly class='streetaddress' type='text' placeholder='$ph' name='$name' maxlength=128 id='$id' value='$fieldvalue'/>";
                }
                $id     = 'streetaddress_' . $this->name;
                $icon   = '';

                /**
                 * Generate an address preview (if needed)
                 */
                $address_preview = '';
                if (0 == $this->showAddressPreview) {
                    $value->origin_iso = $iso;
                    $formatted_address = $value->format();
                    $blank_formatted_address = StreetAddress::getBlankFormattedValue($iso);
                    if ($blank_formatted_address === $formatted_address) {
                        $message = __("Please Enter Address");
                        $formatted_address = "<div class='streetaddress_warning'><i class='fa fa-exclamation-triangle'></i><br><pre>$message</pre></div>";
                    } else {
                        /**
                         * Re-render with country as needed...
                         */
                        switch ($this->showOutputCountry) {
                        case 0:
                            $value->origin_iso = $iso;
                            break;

                        case 1:
                            $value->origin_iso = '++';
                            break;

                        case 2:
                            $value->origin_iso = $this->originISO;
                            break;
                        }
                        $formatted_address = $value->format();
                        $parser = $this->modules->get("TextformatterTagParser");
                        $parser->set('context', ['page' => $this->page]);
                        $parser->format($formatted_address);
                        $formatted_address = "<pre>$formatted_address</pre>";
                    }
                    $address_preview = <<<HTML
        <div class="streetaddress_frame">
            $formatted_address
        </div>
HTML;
                }

                return <<<HTML
    <div class="streetaddress">
        <div class="streetaddress_input_frame">
            <div class="streetaddress_controls" data-id="$id">$icon</div>
            <div class="streetaddress_input" id="$id">$out</div>
        </div>
        $address_preview
        <div class="streetaddress_unused_fields">
            $unused_out
        </div>
    </div>
HTML;
            }
        }

        if (!$known) {
            $table = $this->modules->MarkupAdminDataTable;
            $table->setID($this->className.'Table');
            $table->setEncodeEntities(false);
            $table->setSortable(false);
            $table->headerRow([
                __("Line"),
                __("Value"),
            ]);
            foreach ($fields as $f) {
                $label = mb_convert_case($f, MB_CASE_TITLE, 'utf-8');
                $label = str_replace('_', ' ', $label);
                $label = str_replace('Iso', 'ISO', $label);
                $fieldvalue = htmlspecialchars($value->$f, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                if ('country_iso' === $f) {
                    $input = $country_input;
                } else {
                    $input = "<input class='streetaddress' style='width:100%' type='text' name='{$this->name}_$f' maxlength=128 id='Inputfield_{$this->name}_$f' value='{$fieldvalue}'/>";
                }
                $table->row([
                    $label,
                    $input
                ]);
            }
            return $table->render();
        }
    }



    /**
     * Process the input
     *
     * @param WireInputData $input
     * @return $this
     *
     */
    public function ___processInput(WireInputData $input)
    {
        $name  = $this->attr('name');
        $value = $this->attr('value');

        $fields = StreetAddress::getAddressFieldNames();
        foreach ($fields as $f) {
            $name      = "{$this->name}_$f";
            $newvalue  = strip_tags($input->$name);
            $value->$f = $newvalue;
        }
        $this->trackChange('value');

        return $this;
    }
}
