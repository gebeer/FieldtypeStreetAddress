<?php namespace ProcessWire;

require_once __DIR__ . '/StreetAddress.php';

/**
// TODO add preservation of non-required fields - allows switching between formats.
 *
 */

class InputfieldStreetAddress extends Inputfield {

    public static function getModuleInfo()
    {
        return [
            'title'    => __('Street Address Inputfield'),
            'summary'  => __('Allows country specific formatting of street addresses.'),
            'version'  => '0.0.1',
            'author'   => 'Netcarver',
            'requires' => ["FieldtypeStreetAddress", "MarkupAdminDataTable", "JQuerySelectize"],
        ];
    }


    public function __construct()
    {
        $this->set('permittedISOs', '');            // Allowable country codes
        $this->set('defaultISO', 'us');             // The default country code for new address fields when there is more than one allowable
        $this->set('showInputCountry', 0);          // Show country input if there is only one allowable country?
        $this->set('showOutputCountry', 0);         // Show country in output (never/always/if international)
        $this->set('surpressUnneededFields', 0);    // Show optional fields by default.
        $this->set('validatePostalCode', 0);        // Off by default.
        $this->set('originISO', 'us');              // Helps control address formatting output.
        parent::__construct();
    }

    /**
     * Per the Module interface, init() is called when the system is ready for API usage
     *
     */
    public function init()
    {
        return parent::init();
    }



    protected static function makeTitle(array $parts)
    {
        array_walk($parts, function(&$item, $key) {
            $item = mb_convert_case(str_replace('_', ' ', strip_tags($item)), MB_CASE_TITLE, 'UTF-8');
        });
        return implode(__(', '), $parts);
    }




    protected static function getCountryList()
    {
        return include __DIR__."/countries.php";
    }


    protected static function makeDatalist($data, $id, $current='')
    {
        $id  = htmlspecialchars(strip_tags($id), ENT_HTML5 | ENT_QUOTES, 'utf-8');
        $out = "<select id='$id' placeholder='Country (required)' class='streetaddress streetaddress_country'>";
        foreach ($data as $iso => $country) {
            $country = mb_convert_case($country, MB_CASE_TITLE, 'UTF-8'); // TODO Review!
            $selected = ($current === $iso) ? 'selected=selected ' : '';
            $out .= "<option {$selected}value=\"$iso\" >$country</option>";
        }
        $out.= "</select>";
        return $out;
    }



    protected function makeCountryInput($allowed_countries, $default_country, $current_value)
    {
        if (!is_array($allowed_countries)) {
            $allowed_countries = [];
        }

        $all           = self::getCountryList();
        $num_allowed   = count($allowed_countries);
        $current_value = strtolower($current_value);
        $readonly      = false;

        if ($num_allowed == 1) {
            // Fixed choice: ignore $default_country - the only allowed country overrides it.
            // The inputfield will be prefilled and read-only.
            $default_country = $allowed_countries[0];
            $readonly        = true;
        } else if ($num_allowed > 1) {
            // There is a set of valid choices.
            // The $default_country should be in this set - if it isn't, add it!
            if (!in_array($default_country, $allowed_countries)) {
                $allowed_countries[] = $default_country;
            }
        } else {
            // Free choice from all countries
            // Load the full set of allowed values...
            $allowed_countries = array_keys($all);
        }

        // Handle the case where the current value is not in the allowed countries ISO list...
        if (!in_array($current_value, $allowed_countries)) {
            $current_value = $default_country;
        }

//\TD::barDump($default_country);
//\TD::barDump($allowed_countries, "Allowed Countries - pre");

        // Build array of allowed countries and their names...
        $allowed_countries = array_flip($allowed_countries);
        $allowed_countries = array_intersect_key($all, $allowed_countries);

//\TD::barDump($allowed_countries, "Allowed Countries - post");

        $classes       = 'streetaddress streetaddress_upper address_field_has_list';
        $title         = 'Country, required';
        //$w             = '33%';
        $value         = htmlspecialchars($allowed_countries[$current_value], ENT_HTML5 | ENT_QUOTES, 'utf-8');
        $readonly_attr = '';
        $hidden_attr   = '';
        $id            = "Inputfield_{$this->name}_country";
        if ($readonly) {
            // Build a readonly text input...
            $readonly_attr = ' readonly=readonly ';
            if (0 == $this->showInputCountry) {
                $hidden_attr = ' hidden ';
            }

            $out = "<input $hidden_attr$readonly_attr title='$title' class='$classes' placeholder='$title' type='text' name='{$this->name}_country' maxlength=128 id='$id' value='$value'/>";
        } else {
            /* $datalist_id   = "{$this->name}_country_options"; */
            $out      = self::makeDatalist($allowed_countries, $id, $current_value);
//\TD::barDump($datalist, "Country Options");
        }

//\TD::barDump($out, "Country Output");

        return $out;
    }


    /**
     * Return the completed output of this Inputfield, ready for insertion in an XHTML form
     *
     * @return string
     *
     */
    public function ___render()
    {
        $this->modules->JquerySelectize;

        $value = $this->attr('value') ? $this->attr('value') : new StreetAddress();
//\TD::barDump($this, "InputfieldStreetAddress");
\TD::barDump($value, "Value");


        $country_input     = $this->makeCountryInput($this->permittedISOs, $this->defaultISO, $value->country_iso);

        $country_of_origin = $this->originISO;
        $show_country      = $this->inputShowCountryField;
        $fields            = StreetAddress::getAddressFieldNames();
        $mappings          = StreetAddress::getAddressMappings();
        $unused            = $mappings;
        $known             = false;
        $iso               = $value->country_iso;

        /* switch ($show_country) { */
        /* case 0: */
        /*     $show_country = ($iso !== $country_of_origin); */
        /*     break; */
        /* case 1: */
        /*     $show_country = false; */
        /*     break; */
        /* case 2: */
        /*     $show_country = true; */
        /*     break; */
        /* } */

        if ('' !== $iso) {
            $fmt = StreetAddress::getFormat($iso);
//\TD::barDump($fmt, "fmt");
            if ('' !== $fmt) {
//\TD::barDump($unused, "Unused - initial");
                /**
                 * Address format is known, so build the input form from the format.
                 */
                $known = true;
                $out   = [];
                //$w     = '33%';

                $upper_fields    = str_split(@$fmt['upper']);
                $required_fields = str_split(@$fmt['require']);
                if ('' === $required_fields) {
                    $required_fields = 'NOSACZ'; // If no required fields are mentioned, assume they all are
                }

                $addressfields = $fmt['fmt']."%n%R";
                $addressfields = str_replace('%N', '', $addressfields);
                $addressfields = str_replace('%O', '', $addressfields);
                $addressfields = explode('%', $addressfields);
                array_shift($addressfields);

                foreach ($addressfields as $f) {
                    $fmtcode     = substr($f, 0, 1);
                    $suffix      = substr($f, 1);
                    $is_upper    = in_array($fmtcode, $upper_fields);
                    $is_required = in_array($fmtcode, $required_fields);
                    $key         = @$mappings[$fmtcode];
                    $parts       = [$key];
                    $parts[]     = ($is_required) ? __('Required') : __('Optional');
                    $title       = self::makeTitle($parts);

                    unset($unused[$fmtcode]);

                    // TODO add regex to postcode field? Perhaps as jQuery field validation?
                    /* $regex       = ''; */
                    /* if ('Z' === $fmtcode) { */
                    /*     $regex = ' pattern="' . $fmt['zip'] .'"'; */
                    /* } */

                    $classes     = ['streetaddress'];
                    if (!$is_required && 'country' !== $key) {
                        // TODO remove optional attribute if optional field has a value?
                        $classes[] = 'streetaddress_optional';
                        if (!empty($key) && strlen((string)$value->$key) > 0) {
                            $classes[] = 'streetaddress_optional_nonempty';
                        }
                    }
                    if ($is_upper || 'country' == $key) {
                        $classes[] = 'streetaddress_upper';
                    }
                    if ($is_required) {
                        $classes[] = 'required';
                    }
                    $classes = implode(' ', $classes);


//\TD::barDump(['Field' => $f, 'mapping' => $key, 'Suffix' => $suffix], "Field => Mapping");
                    if ('R' === $fmtcode) {
                        $out[] = $country_input;
                        /* if ('' === $value->$key) { */
                        /*     // Use the country name from the fmt info if the field is blank. */
                        /*     $fieldvalue = $fmt['name']; */
                        /* } else { */
                        /*     // Otherwise, use whatever is stored in the country field - which may not match the ISO!!?? */
                        /*     $fieldvalue = $value->$key; */
                        /* } */
                        /* $fieldvalue = htmlspecialchars($fieldvalue, ENT_HTML5 | ENT_QUOTES, 'UTF-8'); */
                        /* $out[] = "<input title='$title' class='$classes' placeholder='$title' type='text' name='{$this->name}_$key' maxlength=128 id='Inputfield_{$this->name}_$key' value='{$fieldvalue}'/>"; */
                    } else if ('A' === $fmtcode) {
                        $key2 = 'street_address_2';
                        $fieldvalue   = htmlspecialchars($value->$key, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                        $out[] = "<input title='$title' class='$classes' placeholder='$title' type='text' name='{$this->name}_$key' maxlength=128 id='Inputfield_{$this->name}_$key' value='{$fieldvalue}'/><br>";
                        $fieldvalue2  = htmlspecialchars($value->$key2, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                        $classes .= ' streetaddress_optional';
                        if ('' !== $fieldvalue2) {
                            $classes .= ' streetaddress_optional_nonempty';
                        }
                        $title = __('Street Address Line 2, Optional');
                        $out[] = "<input title='$title' class='$classes' placeholder='$title' type='text' name='{$this->name}_$key2' maxlength=128 id='Inputfield_{$this->name}_$key2' value='{$fieldvalue2}'/>";
                    } else if (array_key_exists($fmtcode, $mappings)) {
                        $fieldvalue   = htmlspecialchars($value->$key, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                        $out[] = "<input title='$title' class='$classes' placeholder='$title' type='text' name='{$this->name}_$key' maxlength=128 id='Inputfield_{$this->name}_$key' value='{$fieldvalue}'/>";
                    } else if ('n' === $fmtcode) {
                        // Pass over leading 'n' markers. These can be left over from removing the recipient and/or organisation.
                        if (!empty($out)) {
                            $out[] = "\n";
                        }
                    }

                    if (!empty($suffix)) {
                        $out[] = "<span class='streetaddress_suffix'>$suffix</span>";
                    }
                }
                $ph    = __('Country ISO');
                $title = __('Required');
                $out[] = "<input hidden class='streetaddress' title='$ph, $title' placeholder='$ph' style='width:100%' type='text' name='{$this->name}_country_iso' maxlength=128 id='Inputfield_{$this->name}_country_iso' value='{$iso}'/>";
                $out = implode('', $out);
                $out = preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $out);
                $out = nl2br($out);
                $unused_out = '';
                foreach ($unused as $key) {
                    $fieldvalue   = htmlspecialchars($value->$key, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                    $unused_out .= "<input hidden class='streetaddress' type='text' placeholder='' name='{$this->name}_$key' maxlength=128 id='Inputfield_{$this->name}_$key' value='$fieldvalue'/>";
                }
                $id     = 'streetaddress_' . $this->name;
                //$icon   = '<i class="fa fa-tasks"></i>';
                $icon   = '';

                return <<<HTML
    <div class="streetaddress">
    <div class="streetaddress_frame">
    <div class="streetaddress_controls" data-id="$id">$icon</div>
    <div class="streetaddress_input" id="$id">
    $out
    </div>
    </div>
    <div class="streetaddress_unused_fields">$unused_out</div>
    </div>
HTML;
            }
        }

        if (!$known) {
            $table = $this->modules->MarkupAdminDataTable;
            $table->setID($this->className.'Table');
            $table->setEncodeEntities(false);
            $table->setSortable(false);
            $table->headerRow([
                __("Line"),
                __("Value"),
            ]);
            foreach ($fields as $f) {
                // TODO re-order according to country format (if known)
                $label = mb_convert_case($f, MB_CASE_TITLE, 'utf-8');
                $label = str_replace('_', ' ', $label);
                $label = str_replace('Iso', 'ISO', $label);
                $fieldvalue = htmlspecialchars($value->$f, ENT_HTML5 | ENT_QUOTES, 'UTF-8');
                $table->row([
                    $label,
                    "<input class='streetaddress' style='width:100%' type='text' name='{$this->name}_$f' maxlength=128 id='Inputfield_{$this->name}_$f' value='{$fieldvalue}'/>",
                ]);
            }
            return $table->render();
        }
    }


    /**
     * Process the input from the given WireInputData (usually $input->get or $input->post), load and clean the value for use in this Inputfield.
     *
     * @param WireInputData $input
     * @return $this
     *
     */
    public function ___processInput(WireInputData $input)
    {
        $name  = $this->attr('name');
        $value = $this->attr('value');

        $fields = StreetAddress::getAddressFieldNames();
        foreach ($fields as $f) {
            $name      = "{$this->name}_$f";
            $newvalue  = $input->$name;
            $value->$f = $newvalue;
\TD::barDump([$f => $newvalue], "Processing field $name");
        }
        $this->trackChange('value');

        return $this;
    }


    /**
     * Get any custom configuration fields for this Inputfield
     *
     * @return InputfieldWrapper
     *
     */
    public function ___getConfigInputfields()
    {
        $inputfields = parent::___getConfigInputfields();

        /* $f = $this->modules->get('InputfieldInteger'); */
        /* $f->attr('name', 'input_width'); */
        /* $f->label = 'Input width'; */
        /* $f->attr('value', $this->input_width ? $this->input_width : 100 ); */
        /* $f->attr('size', 10); */
        /* $f->description = 'Width of the inputs in pixels.'; */
        /* $inputfields->append($f); */

        return $inputfields;
    }
}
